





- 무엇인가?
- ㄴ
- 종류
	- 내부 단편화 : 할당된 메모리 블록 내에 사용되지 않는 공간이 남아있는 경우.
	- 외부 단편화 : 사용할 수 있는 메모리의 총량은 충분하지만, 연속적인 큰 블록이 없어서 할당에 실패하는 경우
- 원인
	- 동적 메모리 할당 : 다양한 크기의 메모리 블록이 반복적으로 할당되고 해제되면서 단편화 발생.
	- 메모리 관리 방식 : 메모리 할당기(allocator)가 최적화되지 않거나 특정 패턴을 처리하지 못하는 경우.
- 게임 클라이언트에서
	- 증상
		- 게임 클라이언트는 실시간 요구사항과 메모리 제약이 크므로 단편화가 게임 중단이나 프레임 드랍으로 이어질 수 있음.
	- 원인
		- 동적 자원 관리: 텍스처, 오디오, 네트워크 패킷.
		- 비동기 로딩: 게임의 다양한 데이터가 런타임에 로드되고 해제됨.
		- 메모리 풀 미사용: 정적으로 할당 가능한 데이터도 동적으로 처리하는 경우.
- 해결 방법
	- 제목 / 원리 / 과정 / 장점과 효과 / 단점 / 예시 등을 기술
	- 
- 깊은 이해
	- 저수준
	- 고수준
- 추가 학습 자료
	- "Game Programming Gems" 시리즈: 메모리 최적화 사례 포함.
	- "Effective C++" (Scott Meyers): 메모리 관리와 관련된 기법.
	- "Memory as a Programming Concept in C and C++": 메모리 모델과 관리에 대한 심도 있는 설명









## C#에서 메모리 단편화
- C# CLR
	- CLR의 자동 메모리 관리
		- 가비지 컬랙터
			- 작동방식
			- 단편화 극복
			- 그럼에도 불구하고 메모리 단편화.
		- 대형 객체 힙
	- 효율적으로 코드 작성하기


### 1. C# CLR (공통 언어 런타임)
### 1.1. C# CLR 자동 메모리 관리
- 관리되는 힙
	- CLR은 힙 메모리를 관리함.
	- 객체는 관리되는 힙에 할당되며, 개발자는 `new` 키워드로 객체를 생성하면 됨.
	- class
		- new => 힙
		- 기본적으로 null
		- new 키워드를 통해서 나중에 할당이 가능합니다.
	- struct
		- new => 스택
		- 즉시 할당, 항상 초기화 되어 있고
		- 메서드의 중괄호 스코프를 벗어나면 해제됩니다.
	- 메모리 해제는 가비지 수집기에 의해 자동으로 수행됨.
- 스택
	- 지역 변수 및 메서드 호출은 스택에 저장됨.
	- 메서드 실행이 완료되면 해당 스택 프레임은 자동으로 제거됨.
	- 스택에서는 메모리 단편화가 발생하지 않음.
		- 스택은 Last In, First Out(LIFO) 방식으로 작동하는 메모리 구조임
		- 메모리를 할당할 때는 스택 포인터(stack pointer)를 단순히 증가시키고, 해제할 때는 감소시킴
		- 스택에서는 함수 호출에 따른 로컬 변수 및 매개변수의 메모리가 순차적으로 할당되고, 함수가 반환되면 그 메모리가 자동으로 해제됨
		- 이러한 순차적인 할당과 해제 방식은 메모리가 "구멍" 없이 효율적으로 사용되도록 보장함.
### 1.1.1. C# 가비지 컬렉터
#### 1.1.1.1. 작동 방식, 관리되는 힙 / SOH (Small Object Heap)
- C#으로 작성한 소스 코드를 컴파일해서 실행 파일을 만들고
- 이 실행파일을 실행하면, CLR은 이 프로그램을 위한 일정 크기의 메모리를 확보함.
- C#은 그냥 넓디 넓은 메모리 공간을 통째로 확보해서 하나의 "관리되는 힙, Managed Heap"을 마련하고, 그곳에서 동적인 객체를 관리함.

- 세대 관리
	- 가비지 수집기는 객체를 세대(Generation)로 나누어 관리함
- 종류
	- 0세대
		- 새로 생성된 객체가 배치
		- 가비지 컬랙팅이 가장 자주 일어나는 지역
	- 1세대
		- 0세대에서 살아남은 객체가 1세대로 승격(promoted).
		- 0세대와 2세대 사이, 2세대로 가기에는 쪼끔 애매해서 두 세대 간 이렇게 버퍼를 남겨놨다고 생각하면 좋음.
		- 0세대에서 가비지 컬랙팅을 하고도 부족하면 1세대에서 가비지 컬랙팅을 함.
	- 2세대
		- 장기간 살아남는 객체가 위치.
		- 어차피 오래 살아남았으니 가비지 컬랙터가 그렇게 자주 관리하지 않음
	- 그림 파일![[2024-12-09 관리되는 힙.png]]
		- 왼쪽 진한 초록색은 2세대 객체이고, 중간 명도의 초록색은 1세대 객체, 그리고 오른쪽의 연두색은 0세대 객체의 범위.
		- 가비지 컬랙션에서 살아남을때마다, 0세대는 1세대로 가고, 1세대는 2세대로 감. 2세대는 그냥 2세대로 남음.
	- + LOH
		- 커다란 객체(85,000 바이트 이상)는 이후에 설명할 대형 객체 힙에 저장함
		- 3세대 라고 불리기도 함. 가비지 컬렉터가 해당 영역에 압축 작업을 안 하기 때문
		- 비유를 하자면, 빼빼로 아몬드맛 1개를 우리 방에서 이웃 집으로 들고가는건 괜찮은데, 냉장고 한대를 우리 집에서 옆 집으로 옮겨가는건 엄청 힘들고 무겁기 때문.
- 왜 이렇게 나눴냐
	- 웬만한 메모리가 잘 관리된 어플리케이션에서는 2세대만으로 충분하기 때문
#### 1.1.1.2. C# 가비지 컬랙터에서 메모리 단편화 극복
이런 식으로 메모리를 조금 먹는 작은 객체에 대해서는 객체를 메모리에서 옮길때의 비용이 작으니까, 이렇게 압축을 통해서 메모리 상 객체가 연속적으로 놓이게 됨.

가비지 컬랙터는 아래 3단계를 거쳐서 관리되는 힙의 단편화를 줄임.
- **Mark**: 더 이상 참조되지 않는 객체를 식별.
- **Sweep**: 식별된 객체의 메모리를 해제.
- **Compact** (필요한 경우): 남아 있는 객체를 연속적으로 이동시켜 메모리 단편화를 줄임.
#### 1.1.1.3. 그럼에도 일어날 수 있는 매니지드 힙에서의 메모리 단편화
- 압축 과정은 비용이 크므로, GC는 압축이 반드시 필요할 때에만 수행하려고 함.
	- 가비지 컬랙터의 작업은 0세대 객체 먼저 작업하고, 그럼에도 불구하고 부족하면 1세대 객체에 대해 작업함.
	- 그럼에도 불구하고 또 메모리가 부족함을 느끼면 비로소 2세대 객체에 대해 가비지 컬랙션 작업을 수행함.
	- 따라서 GC가 압축을 수행하지 않는 경우, 단편화가 발생할 수 있음
		- 그리고 GC에서 압축을 수행하면, 가비지 컬렉팅을 하느라 CPU 리소스를 잡아먹는 일이 발생함.
	- 비슷한 이유로 아래에 설명할 LOH에도 비슷한 일이 벌어짐.
![[Pasted image 20241229205014.png]]
### C# 1.1.2. CLR 대형 객체 힙(보통 LOH 라고 불립니다)
- .NET GC(가비지 수집기)는 개체를 큰 개체와 작은 개체로 나눔.
- 개체가 크면 그 특성 중 일부는 개체가 작을 때보다 중요함.
	- 예를 들어 개체 압축, 즉 힙의 다른 위치에서 메모리에 복사하는 경우 비용이 많이 들 수 있음.
- 이 때문에 가비지 수집기는 LOH(큰 개체 힙)에 큰 개체를 배치함.

> 개체 크기가 85,000바이트 이상이면 큰 개체로 간주됩니다. 이 숫자는 성능 튜닝으로 결정됩니다. 개체 할당 요청이 85,000바이트 이상이면 런타임에서 이를 큰 개체 힙에 할당합니다.
> https://learn.microsoft.com/ko-kr/dotnet/standard/garbage-collection/large-object-heap

- LOH는 SOH와는 다른 방식으로 GC가 처리됨.
- LOH는 Generation 2 GC 사이클에서만 수집됨.
	- 따라서, 큰 객체는 더 오래 메모리에 남아 있을 가능성이 크다.
	- 이유는 큰 객체를 이동시키는 데 비용이 많이 들기 때문에 GC에서 LOH를 이동시키지 않음. 대신 압축(compaction)이 수행되지 않음
	- LOH는 큰 객체가 연속적인 메모리 블록에 할당되기를 요구함. 이는 메모리 단편화의 주요 원인이 될 수 있음
- 할당 방식도 다름
	- 소형 객체 힙은 다음 객체를 할당할 포인터에 객체를 위치시킴
	- 그러나 대형 객체 힙은 객체의 크기를 계산한 뒤, 그만한 여유 공간이 있을 때 힙을 탐색하여 할당.
	- 앞서 설명한 대로, 압축이 수행되지 않아서 메모리 단편화가 발생하고, 이런 단편화가 누적됨.
	- 단편화가 심각해지면 새로운 대형 객체를 할당하기 위해 Gen 2나 LOH에서 가비지 컬랙션 작업이 실행
### 가비지 컬랙션에 기반한 효율적으로 작성하는 방법
- 배열 풀링(Array Pooling) : 큰 배열을 빈번히 생성하고 폐기하는 대신, 재사용 가능한 배열 풀을 사용함. .NET Core 및 .NET Framework에서는 `System.Buffers.ArrayPool<T>`를 사용하여 풀링을 구현할 수 있음.
- 객체 할당 회수 최소화 : 가장 기본적인 지침임. 객체 할당 속도가 빠르긴 하지만, 너무 많은 수의 객체는 관리하게 어렵고, 관리되는 힙의 메모리 포화 및 가비지 컬랙터의 작업을 초래함.
- 큰 객체를 할당을 만드는 것을 피하기 : 앞서 설명한 것처럼 SOH에서는 압축 과정을 통해서 메모리 단편화 문제를 해결하지만, LOH에서는 압축이 진행되지 않아 단편화가 발생함.
	- 세분화된 할당 전략 : 큰 객체를 여러 개의 작은 객체로 나눠 할당하면 LOH 사용을 줄일 수 있음.
- 메모리 프로파일링 도구 사용 : 메모리 단편화 문제를 파악하려면 .NET 메모리 프로파일러(예: Visual Studio의 진단 도구)를 사용하여 LOH 사용 패턴과 단편화를 분석함.







# 앞으로 찾아볼 내용
- 운영체제
	- 메모리 관련
	- 가상 메모리
	- 물리 메모리
	- C의 new
	- 동적 할당
	- 스택
	- 런타임 전 할당
	- 프로세스와 스레드의 차이
- 가비지 컬렉터 종류 찾아보기
	- 워크스테이션 GC
	- 서버 GC
	- 증진적 GC
	- 유니티에서 GC
- 가비지 컬랙터를 선택하는 일
	- 각 장단점 찾아보기

메모리 단편화
- 내부 단편화
- 외부 단편화


하나의 프로세스가 메모리에서 할당을 받을 건데 해당 어플리케이션에서 각자 영역을 가질 것입니다.
- 페이징 기법
	- 이 페이징 기법과 때놓을 수 없는게 가상메모리라 결국 프로세스와 쓰레드차이...
- 세그먼테이션 기법

우리가 쓰는 메모리는 전부 비다이렉트 메모리다
항상 고정된 자리에 고정된 메모리
- 효율성보다는 추상화
	- 



개념적으로 이해하지 말고(설명은 누구나 가능)
코드나 스크립트를 작성하기


예시를 찾아서 공부하기
어떤 식으로 사용하는지 실제로 경험할 것
응용하고 활용하기

부모의 생성자에서 왜 가상함수를 호출하면 안되는가?
가상함수 테이블


헛짓거리 많이 하기
- 

new에서 malloc을 호출함
=> 왜 그런걸까?
=> 예시 찾아보기


VirtualAlloc, VirtualFree
가장 중요한건 프로토콜
그리고 인터페이스


-


