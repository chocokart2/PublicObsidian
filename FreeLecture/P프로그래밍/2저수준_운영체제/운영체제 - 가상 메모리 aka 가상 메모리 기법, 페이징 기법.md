#정보
# 1. 제목 :

# 2. 3줄 요약
- 1.
- 2.
- 3.
# 3. 이해를 위한 사전 지식(빌드업)
- [[컴퓨터 구조 - CPU]]
	- CPU의 32bit, 64bit은 CPU의 데이터 처리 능력과 주소 공간을 나타내는 용어
	- 
- CPU - RAM - Disk
- [[운영체제 - 페이징 기법]]
- [[운영체제 - 페이지]]
- [[_미완)운영체제 - 프레임]]
# 4. 설명
## 4.1. 이론
### 4.1.1. 특징
### 4.1.1.1. 특징 : 가상 메모리는 물리적로 존재하지 않음
가상 실제로 존재하지 않지만, CPU나 프로세스 입장에서는 하나의 메모리 공간처럼 보여짐.
한 프로세스가 사용하는 메모리 공간은, 물리적 요소(RAM, 보조기억장치 등)에 여기저기 조각들로 퍼져 있음.
예를 들어, 하드웨어 입장에서 a, b, c, d 라는 공간을 사용한다고 하면, a는 10번지, b는 234번지, c는 2번지, d는 70번지에 위치하는 등.

하지만 CPU나 프로세스 입장에서 자원을 조작하기 위해선 이런 내용은 너무 복잡해 보이니까 내부적인 복잡한 내용은 추상화시켜 일련의 데이터 공간처럼 보이게 만듦.
### 4.1.1.2. 특징 : 보안성 및 안정성
프로그램은 메모리에 직접 접근하는 것이 아닌 간접 접근하며 기본적으로 프로그램간 메모리가 분리되며 필요한 경우에만 특정 메모리를 서로 공유해 메모리 접근에 대한 오류를 줄여 보안성 및 안정성이 증가한다.

### 4.1.1.3. 특징 : 개발 용이성 및 메모리 관리
- 프로그램은 각자 고유한 메모리를 사용하며, 어느정도 큰 용량으로 고정되어 있음. 따라서 실제 메모리 용량과는 무관하게 프로그램을 만들 수 있음
- 운영체제는 가상 메모리 중에서 현재 사용되지 않는다고 판단되는 메모리 조각들(페이지라고 함)을 스왑하여 실제 메모리 공간을 확보하는 등의 관리를 함.
	- 메모리를 압축한다는 설도 있으나 해당 내용에 대해선 추가 조사가 필요. #추가조사필요 
### 4.1.1.4. 특징: 내부 단편화 해결을 책임지지 않음.
내부단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임을 다 채울 수 없다. 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다.
![[가상메모리-내부단편화문제.png]]
https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-13.-%ED%8E%98%EC%9D%B4%EC%A7%95
바로 이해가 되지 않으실텐데, 4.1.3.번 문항을 통해서 이해하길 바람.

### 4.1.2. 구성 요소
- CPU
- 가상 주소 공간
- 매핑 테이블 : 매핑 방식에 따라 다르게 보여지더라고요.
	- 직접 매핑 테이블
	- 변환 색인 버퍼 + 스왑 영역
	- 스왑 영역 + 페이지 디렉토리 + 묶음 페이지 테이블
	- 역매핑 테이블
- MMU
- RAM
- DISK

### 4.1.3.1. 작동원리: (페이지 테이블 매핑 방식)MMU가 CPU의 가상 주소를 물리 주소로 매핑함
- CPU가 가상 메모리에 접근할때, CPU가 사용하는 주소 규칙은 가상 주소이다.
- 그리고 메모리나 하드디스크가 알아듣는 주소 규칙은 물리 주소임.
- 그래서 MMU가 사이에 끼여들어서 가상 주소를 물리 주소로 바꿔주는 역할을 한다.
- 하지만 앞서 들었던 4.1.1.1. 특징을 한번 보면. 가상 메모리는 해당 공간이 페이지 단위로 쪼개져, 실질적으로 그 공간은 물리적 메모리, 디스크에 프레임 단위로 뿌려져 있다. 따라서 CPU가 b번 페이지를 원하면 운영체제는 234에 위치한 프레임을 갖다줘야 한다.
- 다시말해 필요한 부분에 해당하는 페이지가 있으면, 그것을 물리적으로 실존하는 곳에 접근하도록 하는 변환 방식이 필요하다는거다.

사이트마다 이야기 하는 방식이 다름
https://lordofkangs.tistory.com/626
- 여기선 집합-연관 매핑을 언급함
https://sommda.tistory.com/63
- 직접 매핑, 연관 매핑, 집합-연관 매핑, 역매핑

따라서 지금은 그냥 다 설명하기로 함
#### 4.1.3.1.1. 직접 매핑
페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식.
물리 메모리 상 페이지의 P번째 주소가 시작 주소(PTBR)로부터 P번째 위치에 존재함.
![[Pasted image 20250119192953.png]]
https://sommda.tistory.com/63
![[Pasted image 20250119195425.png]]
https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-13.-%ED%8E%98%EC%9D%B4%EC%A7%95

#### 4.1.3.1.2. 연관 매핑
- 페이지 테이블 전체를 스왑 영역에서 관리함
- 변환 색인 버퍼(aka. 연관 레지스터)
	- 페이지 테이블의 일부만 물리 메모리에 가지고 있음
	- 이는 일부 내용만 무작위로 배치하여 페이지 번호와 프레임 번호 둘다 표시함
- 찾는 방법
	- 가상 주소(페이지 번호 + 거리)가 주어지면
	- 메모리에 접근하기 위해 먼저 변환 색인 버퍼를 하나씩 찾아본다.
		- 만약 원하는 페이지 번호가 있으면 TLB hit이라고 하며 물리 주소 획득
		- 없으면 이를 TLB miss라고 하며 스왑 영역에서 뒤져봄.
![[Pasted image 20250119194253.png]]
https://sommda.tistory.com/63

- 왜 이런 짓을 하는거야?
	- 직접 매핑 장점 : 각 가상 페이지는 물리적 메모리의 고정된 슬롯에 매핑 -> 주소 변환이 간단하며, 오직 하나의 위치만 확인하면 됨.
		- 단점 : 같은 슬롯에 여러 가상 페이지가 매핑되면 페이지 교체가 잦아짐 + 메모리 활용 효율이 낮아질 수 있음
			- 왜?
				- 직접 매핑의 단점이 드러나는 환경
				- 가상 페이지 접근 패턴이 주기적이거나 특정 범위 내에서 집중적으로 이루어지는 경우
					- 예를 들어, 특정 슬롯에 매핑되지 않는 가상 페이지가 많으면 그 슬롯은 **비어 있는 상태로 낭비**될 수 있음.
				- 슬롯 수가 가상 페이지 수보다 상대적으로 적어 충돌 빈도가 높은 경우
	- 연관 매핑 장점
		- 충돌 문제가 없음. 가상 페이지는 자유롭게 어떤 슬롯에도 매핑 가능하므로 메모리 활용도가 높음.
		- 페이지 교체 빈도가 감소
	- 연관 매핑 단점
		- 주소 변환이 직접 매핑보다 느릴 수 있음.
		- 연관 기억 장치를 사용하는 검색 과정에서 병렬 비교를 수행해야 하므로 하드웨어 복잡도가 증가
		- 비용이 더 많이 들며, 전력 소모도 높아질 수 있음.

#### 4.1.3.1.3. 집합-연관 매핑

- 모든 페이지 테이블을 스왑 영역에서 관리, 일부만 물리 메모리로 가져옴
- 페이지 테이블을 일정한 집합으로 자르고, 자른 덩어리 단위로 물리 메모리로 가져온다.
- 이를 통해 연관 매핑의 느린 문제를 개선할 수 있음
- 예를 들면, 25개짜리 페이지가 있으면, 이를 5개씩 묶어 자른다. 그리고 각 5개를 폴더처럼 묶어서 묶음들끼리 나열된 페이지 테이블인 디렉터리 페이지 테이블을 하나 더 생성한다.
- 디렉터리 페이지 테이블에는 자른 테이블이 물리 메모리에 있는지, 스왑 영역에 있는지를 표시한다.
	- 있으면 해당하는 묶음 페이지로 가고, 없으면 스왑 영역에서 탐색한다. 
- 가상 주소는 다음 형식을 따른다
	- 디렉터리 테이블 번호
	- 묶음 페이지 테이블 번호
	- 디스턴스
- 이를 통해 묶음 페이지 테이블을 전부 탐색하지 않게 되어 주소 변환 시간이 단축된다.
![[Pasted image 20250119194738.png]]
https://sommda.tistory.com/63
#### 4.1.3.1.4. 역 매핑
- 역매핑은 물리 메모리의 프레임 번호를 기준으로 테이블을 구성한다.
	- 프로세스의 수와 상관없이 테이블이 하나만 존재하며, 테이블의 크기가 매우 작다
	- 물리적 메모리의 페이지 수만큼 테이블의 크기가 결정되기 때문
	- 크기 면에선 효율적이나, 테이블 전체를 탐색하는 과정에서 느려질 수 있음.
	- 질문 : 역매핑 과정에서 원하는 페이지가 디스크에 있으면 어쩌죠?
		- 이를 해결하려면 프로세스마다 확장 페이지 테이블(extended page table)을 유지해야 한다
			- https://jonghoonpark.com/2024/01/06/os-ch-10-virtual-memory-4
			- #추가조사필요 
	- 메모리 관리자는 주소 변환을 해야하는 프로세스의 아이디와, 페이지 번호가 물리 메모리에 있는지, 역매핑 테이블에서 검색한다.
![[Pasted image 20250119200417.png]]
https://sommda.tistory.com/63
![[Pasted image 20250119200435.png]]
https://sommda.tistory.com/63

### 4.1.3.2. 작동원리: Demand paging 
CPU가 페이지를 필요로 할때, 페이지를 메모리에 올리는 것이다

####  4.1.3.2.1. valid-invalid bit
Demand paging은 page table에서 해당 page가 메모리에 있는지를 나타내는 valid-invalid bit를 사용한다. bit가 invalid인 경우 페이지가 물리적 메모리에 없다는 것이다.
따라서 처음에는 모든 page entry가 invalid로 초기화되어있고, 주소 변환 시 bit가 invalid로 되어있다면 page fault라는 오류가 발생한다. 
#### 4.1.3.2.2. 페이지 폴트
Demand paging은 page table에서 해당 page가 메모리에 있는지를 나타내는 valid-invalid bit를 사용한다. bit가 invalid인 경우 페이지가 물리적 메모리에 없름
### 4.1.3.3. 작동원리: 페이지 교체 알고리즘

### 4.1.3.4. 작동원리: 보호와 공유


## 4.3. 등장 배경


초창기 컴퓨터에서는 사용 가능한 RAM의 용량이, 가장 큰 실행 애플리케이션의 주소 공간보다 커야 했음. 그렇지 않을 경우 "메모리 부족" 오류에 의해 해당 애플리케이션을 실행할 수 없었음.
이후 컴퓨터에서는 프로그래머가 애플리케이션의 일부분만 기억장치에 올려 실행하도록 지정할 수 있게 하는 오버레이 기법을 사용하여 메모리 부족 문제를 해결하고자 했음. 하지만 이 역시 전반적인 메모리 부족 문제를 해결할 수 없었음. 오버레이를 사용하는 프로그램은 그렇지 않은 프로그램보다는 메모리를 덜 사용했지만, 애초에 시스템이 프로그램을 위한 충분한 메모리를 갖추고 있지 않은 경우에는 결국 똑같은 메모리 부족 오류가 발생했음.

## 4.4. 용어 소개
가상 메모리는 메모리가 실제 메모리보다 많아 보이게 하는 기술로, 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행이 가능하다는 점에 착안하여 고안되었음.

애플리케이션이 실행될 때, 실행에 필요한 일부분만 메모리에 올라가며 애플리케이션의 나머지는 디스크에 남게 됨. 즉, 디스크가 RAM의 보조 기억장치(backing store)처럼 작동하는 것임.

가상 메모리를 구현하기 위해서는 컴퓨터가 특수 메모리 관리 하드웨어를 갖추고 있어야만 함.
- 다음을 참고하세요
	- [[운영체제 - MMU(Memory Management Unit, 메모리 관리 장치)]]

# 5. 추가 링크
## 5.1. 왜 이것이 작동 되는가?
- 링크
## 5.2. 이것은 어디에 활용되는가?
### 5.2.1. 이후 개념
- 링크
### 5.2.2. 해결하려는 문제
- 링크
## 5.3. 교재 및 학습자료 커리큘럼 링크
- 링크
## 5.4. 출처
- 링크
## 5.5. 그 외 추가적인 정보
- 링크
- 과거에는 이렇게도 했답니다.
	- 옵시디언 링크 : [[운영체제 - 오버레이 기법]]
- 폰 노이만 구조 기반
	- 프로그램의 코드는 무조건 메모리에 올려서 실행되어야 한다.
	- 
