#정보
# 1. 제목 :

# 2. 3줄 요약
- 1.
- 2.
- 3.
# 3. 이해를 위한 사전 지식(빌드업)
- [[컴퓨터 구조 - CPU]]
	- CPU의 32bit, 64bit은 CPU의 데이터 처리 능력과 주소 공간을 나타내는 용어
	- 
- CPU - RAM - Disk
- [[운영체제 - 페이징 기법]]
- [[운영체제 - 페이지]]
- [[_미완)운영체제 - 프레임]]
# 4. 설명
## 4.1. 이론
### 4.1.1. 특징
### 4.1.1.1. 특징 : 가상 메모리는 물리적로 존재하지 않음
가상 실제로 존재하지 않지만, CPU나 프로세스 입장에서는 하나의 메모리 공간처럼 보여짐.
한 프로세스가 사용하는 메모리 공간은, 물리적 요소(RAM, 보조기억장치 등)에 여기저기 조각들로 퍼져 있음.
예를 들어, 하드웨어 입장에서 a, b, c, d 라는 공간을 사용한다고 하면, a는 10번지, b는 234번지, c는 2번지, d는 70번지에 위치하는 등.

하지만 CPU나 프로세스 입장에서 자원을 조작하기 위해선 이런 내용은 너무 복잡해 보이니까 내부적인 복잡한 내용은 추상화시켜 일련의 데이터 공간처럼 보이게 만듦.
### 4.1.1.2. 특징 : 보안성 및 안정성
프로그램은 메모리에 직접 접근하는 것이 아닌 간접 접근하며 기본적으로 프로그램간 메모리가 분리되며 필요한 경우에만 특정 메모리를 서로 공유해 메모리 접근에 대한 오류를 줄여 보안성 및 안정성이 증가한다.

### 4.1.1.3. 특징 : 개발 용이성 및 메모리 관리
- 프로그램은 각자 고유한 메모리를 사용하며, 어느정도 큰 용량으로 고정되어 있음. 따라서 실제 메모리 용량과는 무관하게 프로그램을 만들 수 있음
- 운영체제는 가상 메모리 중에서 현재 사용되지 않는다고 판단되는 메모리 조각들(페이지라고 함)을 스왑하여 실제 메모리 공간을 확보하는 등의 관리를 함.
	- 메모리를 압축한다는 설도 있으나 해당 내용에 대해선 추가 조사가 필요. #추가조사필요 
### 4.1.1.4. 특징: 내부 단편화 해결을 책임지지 않음.
내부단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임을 다 채울 수 없다. 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다.


바로 이해가 되지 않으실텐데, 4.1.3.번 문항을 통해서 이해하길 바람.

### 4.1.2. 구성 요소
- CPU
- 가상 주소 공간
- 매핑 테이블 : 매핑 방식에 따라 다르게 보여지더라고요.
	- 직접 매핑 테이블
	- 변환 색인 버퍼 + 스왑 영역
	- 스왑 영역 + 페이지 디렉토리 + 묶음 페이지 테이블
	- 역매핑 테이블
- MMU
- RAM
- DISK

### 4.1.3.1. 작동원리: (페이지 테이블 매핑 방식)MMU가 CPU의 가상 주소를 물리 주소로 매핑함
- CPU가 가상 메모리에 접근할때, CPU가 사용하는 주소 규칙은 가상 주소이다.
- 그리고 메모리나 하드디스크가 알아듣는 주소 규칙은 물리 주소임.
- 그래서 MMU가 사이에 끼여들어서 가상 주소를 물리 주소로 바꿔주는 역할을 한다.
- 하지만 앞서 들었던 4.1.1.1. 특징을 한번 보면. 가상 메모리는 해당 공간이 페이지 단위로 쪼개져, 실질적으로 그 공간은 물리적 메모리, 디스크에 프레임 단위로 뿌려져 있다. 따라서 CPU가 b번 페이지를 원하면 운영체제는 234에 위치한 프레임을 갖다줘야 한다.
- 다시말해 필요한 부분에 해당하는 페이지가 있으면, 그것을 물리적으로 실존하는 곳에 접근하도록 하는 변환 방식이 필요하다는거다.

사이트마다 이야기 하는 방식이 다름
https://lordofkangs.tistory.com/626
- 여기선 집합-연관 매핑을 언급함
https://sommda.tistory.com/63
- 직접 매핑, 연관 매핑, 집합-연관 매핑, 역매핑

따라서 지금은 그냥 다 설명하기로 함
#### 4.1.3.1.1. 직접 매핑
페이지 테이블 전체가 물리 메모리의 운영체제 영역에 존재하는 방식.
물리 메모리 상 페이지의 P번째 주소가 시작 주소(PTBR)로부터 P번째 위치에 존재함.
https://sommda.tistory.com/63

### 4.1.3.2. 작동원리: Demand paging 
CPU가 페이지를 필요로 할때, 페이지를 메모리에 올리는 것이다

####  4.1.3.2.1. valid-invalid bit
Demand paging은 page table에서 해당 page가 메모리에 있는지를 나타내는 valid-invalid bit를 사용한다. bit가 invalid인 경우 페이지가 물리적 메모리에 없다는 것이다.
따라서 처음에는 모든 page entry가 invalid로 초기화되어있고, 주소 변환 시 bit가 invalid로 되어있다면 page fault라는 오류가 발생한다. 
#### 4.1.3.2.2. 페이지 폴트

### 4.1.3.3. 작동원리: 페이지 교체 알고리즘


## 4.3. 등장 배경


초창기 컴퓨터에서는 사용 가능한 RAM의 용량이, 가장 큰 실행 애플리케이션의 주소 공간보다 커야 했음. 그렇지 않을 경우 "메모리 부족" 오류에 의해 해당 애플리케이션을 실행할 수 없었음.
이후 컴퓨터에서는 프로그래머가 애플리케이션의 일부분만 기억장치에 올려 실행하도록 지정할 수 있게 하는 오버레이 기법을 사용하여 메모리 부족 문제를 해결하고자 했음. 하지만 이 역시 전반적인 메모리 부족 문제를 해결할 수 없었음. 오버레이를 사용하는 프로그램은 그렇지 않은 프로그램보다는 메모리를 덜 사용했지만, 애초에 시스템이 프로그램을 위한 충분한 메모리를 갖추고 있지 않은 경우에는 결국 똑같은 메모리 부족 오류가 발생했음.

## 4.4. 용어 소개
가상 메모리는 메모리가 실제 메모리보다 많아 보이게 하는 기술로, 어떤 프로세스가 실행될 때 메모리에 해당 프로세스 전체가 올라가지 않더라도 실행이 가능하다는 점에 착안하여 고안되었음.

애플리케이션이 실행될 때, 실행에 필요한 일부분만 메모리에 올라가며 애플리케이션의 나머지는 디스크에 남게 됨. 즉, 디스크가 RAM의 보조 기억장치(backing store)처럼 작동하는 것임.

가상 메모리를 구현하기 위해서는 컴퓨터가 특수 메모리 관리 하드웨어를 갖추고 있어야만 함.
- 다음을 참고하세요
	- [[운영체제 - MMU(Memory Management Unit, 메모리 관리 장치)]]

# 5. 추가 링크
## 5.1. 왜 이것이 작동 되는가?
- 링크
## 5.2. 이것은 어디에 활용되는가?
### 5.2.1. 이후 개념
- 링크
### 5.2.2. 해결하려는 문제
- 링크
## 5.3. 교재 및 학습자료 커리큘럼 링크
- 링크
## 5.4. 출처
- 링크
## 5.5. 그 외 추가적인 정보
- 링크
- 과거에는 이렇게도 했답니다.
	- 옵시디언 링크 : [[운영체제 - 오버레이 기법]]
- 폰 노이만 구조 기반
	- 프로그램의 코드는 무조건 메모리에 올려서 실행되어야 한다.
	- 
