#정보
# 1. 제목 :

# 2. 3줄 요약
- 1.
- 2.
- 3.
# 3. 이해를 위한 사전 지식(빌드업)
- 링크
# 4. 설명
## 4.1. 이론

### 4.1.1. 프로세스
포그라운드 프로세스
사용자가 보는 앞에서 실행하는 프로세스

백그라운드 프로세스
사용자가 보지 못하는 뒤편에서 실행되는 프로세스

데몬(유닉스 운영체제) / 서비스(윈도우 운영체제)
백그라운드 프로세스 중에서 사용자와 상호작용하지 않는 것

### 4.1.2. 프로세스 제어 블록(PCB)
실행할 프로세스는 많음. 그러나 CPU 자원은 한정적이기 때문에, CPU가 여러 프로세스를 돌아가면서 잠깐잠깐씩 실행함.

--> 그러면 프로세스를 쓰는 시간은 어떻게 결정하죠? : 시간이 다 되었음을 알리기 위해 타이머 인터럽트를 사용함. 타이머 인터럽트(타임아웃 인터럽트) : 클럭신호를 발생시키는 장치에 의해 주기적으로 발생하는 하드웨어 인터럽트

--> 따라서 운영체제가 이를 관리하기 위해, 프로세스 제어 블록이라는 자료구조를 이용함, PCB는 프로세스와 관련된 정보를 저장함.
- PCB는 커널 영역에서 생성됨
- PCB 생애 주기 : 프로세스가 생성 시 만들어지고, 실행이 끝나면 폐기됨.
- PCB에 담기는 정보
	- 프로세스 ID / PID : 프로세스 식별을 위한 번호 / 같은 일을 수행하더라도 프로세스가 다르면 PID도 다름
	- 레지스터 값 : 레지스터는 CPU가 연산하면서 기억해야할 중간 정보를 기억함. / 따라서 이전까지 진행했던 작업을 그대로 이어 실행하기 위해, PCB에 기록된 레지스터 값을 사용하여 레지스터 상태를 복원함. (예 : 프로그램 카운터)
	- 프로세스 상태 : 프로세스가 어떤 상태인지를 기록한다 (예 : 입출력 대기 / CPU 사용 대기 / CPU 점유 중)
	- CPU 스케쥴링 정보 : 프로세스가 언제, 어떤 순서로 CPU를 할당받을지
	- 메모리 관리 정보 : 프로세스마다 메모리에 저장된 위치가 다름 --> 프로세스가 어느 주소에 저장되어 있는지에 대한 정보가 필요 --> 베이스 레지스터 / 한계 레지스터 값 / 페이지 테이블 정보 등을 기억해야 함.
	- 사용한 파일과 입출력장치 목록 : 해당 프로세스에 할당된 입출력장치 / 열어놓은 파일의 정보들
### 4.1.3.  문맥 교환
4.1.2.에서 운영체제는 CPU의 시간을 쪼개서 여러 프로세스를 잠깐잠깐씩 실행한다고 했다.

이때 프로세스는 시간이 다 된 프로세스 A는 이런 중간 정보A'를 저장하고, CPU를 점유할 프로세스B는 자신의 PCB에 저장된 중간 정보B'를 불러와 프로세스 B는 가장 마지막에 B가 CPU를 양보하기전에서부터 작업을 시작하게 된다.

이런 중간 정보를 문맥(context)이라고 한다.
- 이런 문맥은 PCB에 저장된다.
- 프로세스가 CPU를 더이상 못 쓰는 상태 (예 : CPU를 쓰는 시간이 다 됨, 예기치 못한 상황에 인터럽트가 떠서 CPU를 못 씀)에 이런 문맥을 PCB에 저장해둔다
- 그 프로세스가 CPU를 쓸 수 있는 상황이 되었을때 PCB의 문맥을 복구함.

문맥 교환
기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것을 문맥 교환이라고 함.
- 문맥 교환은 빠르게 실행되며, 아주 자주 실행되기 때문에, 프로세스가 동시에 실행되는 것처럼 느껴지게 만들 수 있음.

### 4.1.4. 프로세스의 메모리 영역

- 메모리에 배치될 프로세스는 커널 영역과 사용자 영역으로 쪼갤 수 있음
	- 커널 영역
		- PCB
	- 사용자 영역
		- 코드 영역
		- 데이터 영역
		- 힙 영역
		- 스텍 영역
#### 4.1.4.1. 코드 영역(텍스트 영역)
실행할 수 있는 코드 / 기계어로 이루어진 명령어가 저장됨
(CPU마다 명령어 코드가 다 달라요)
![[Pasted image 20250303185641.png]]
#### 4.1.4.2. 데이터 영역
프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
- 전역 변수 등이 저장됨
- 전역 변수는 프로그램이 죽을때까지 여전히 살아 있으니, 따라서 그 크기는 고정되며, 이에 따라 정적 할당 영역이라고 불림
#### 4.1.4.3. 힙 영역
- 프로그래머가 직접 할당할 수 있는 저장 공간
- 또한 해당 영역을 다 사용하고 돌려줄때, 이를 반환해야 하는데, 이는 운영체제에게 해당 공간을 사용하지 않겠다고 말하는것과 같음.
- 물론 할당하고 까먹으면 메모리 누수가 발생함.
- 이렇게 프로그래머가 직접 할당하고 제거하니 역동적으로 할당하는 크기가 바뀌므로 동적 할당 영역이라고 불림
#### 4.1.4.4. 스택 영역
- 데이터를 일시적으로 저장하기 위한 공간
- 함수의 매개변수, 지역 변수 등이 저장됨.
- 이런 일시적 변수들은 스택 영역에 PUSH되고, 스코프에서 벗어사 더이상 안 쓰게 되면 자동적으로 POP됨. 웬만하면 컴파일러가 함수 호출과 반환을 관리하기 때문에 메모리의 누수 위험이 덜함.
- 이것도 함수의 흐름에 따라 잡아먹는 영역의 크기가 바뀌므로 동적 할당 영역이라고 불림.

일반적으로, 힙 영역은 메모리의 낮은 주소에서 출발하여 점차 높은 주소로 할당되고, 스택 영역은 높은 주소에서 출발하여 낮은 주소로 할당되어 겹칠 일을 최대한 줄임.

### 4.1.5. 프로세스 상태
#### 4.1.5.1. 생성 상태(new)
프로세스를 생성 중인 상태
이제 막 메모리에 적재 되어 PCB를 할당받은 상태
--> 생성이 끝나면 준비 상태가 됨
#### 4.1.5.2. 준비 상태(ready)
CPU를 할당받아 실행할 수 있지만, 아직 자신의 차례가 아니라서 기다리고 있는 상태
--> CPU를 할당 받으면 실행 상태로 변함(디스패치dispatch 라고 함.)
#### 4.1.5.3. 실행 상태(running)
CPU를 할당받아 실행 중인 상태
실행 상태인 프로세스는 일정 시간동안만 CPU를 사용할 수 있음
--> 타이머 인터럽트 발생 : 준비 상태로 변함
--> 입출력 장치의 작업이 끝나는 것을 기다려야 하는 경우 : 대기 상태
#### 4.1.5.4. 대기 상태(blocked)
- 프로세스는 실행 도중 입출력장치를 사용하는 경우가 있음
- 문제는 입출력 작업은 CPU에 비해 처리 속도가 느림
- 따라서 프로세스는 입출력이 끝날 때까지 기다려야 함.
--> 입출력 작업이 완료 되면 다시 준비 상태로 변함
+) 입출력 작업 외에도 있을 수 있음
- 자원 요청 : 프로세스가 필요한 자원을 사용할 수 없을 때
- 동기화 작업 : 다른 프로세스와 동기화를 기다릴 때.
- 스케줄링 : 운영체제의 스케줄러가 지금 당장 다른 프로세스 실행해야 한다고 할때, 이런 프로세스는 운영체제가 부를 때까지 기다림.
#### 4.1.5.5. 종료 상태(terminated)
- 프로세스가 종료된 상태
- 운영체제는 PCB와 프로세스가 사용한 메모리를 정리함.

머리아파서 정리한 그림
아주 좋아
![[Pasted image 20250303200102.png]]
### 4.1.6. 프로세스 계층 구조
프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 호출할 수 있음.
새로운 프로세스를 낳은 프로세스는 부모 프로세스, 부모 프로세스에 의해 태어난 프로세스를 자식 프로세스라고 함.

--> PID는 프로세스를 구별하기 위한 식별번호임. 따라서 프로세스가 다르면 아이디 값도 다름.
--> 하지만 자식  프로세스가 부모 프로세스가 누구인지를 알아내기 위해 PCB에서는 Parent PID(PPID)를 저장하여 부모 프로세스의 PID를 집어넣음.


### 4.1.7. 프로세스 생성 기법











## 4.2. 예시
- 예시 상황 및 코드 작성
# 5. 추가 링크

## 5.1. 왜 이것이 작동 되는가?
- 링크
## 5.2. 이것은 어디에 활용되는가?
### 5.2.1. 이후 개념
- 링크
### 5.2.2. 해결하려는 문제
- 링크
## 5.3. 교재 및 학습자료 커리큘럼 링크
- 링크
## 5.4. 출처
- 링크
## 5.5. 그 외 추가적인 정보
- 링크


